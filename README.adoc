= tengi - Near-Realtime Communication Foundation

image:https://badges.gitter.im/Join%20Chat.svg[link="https://gitter.im/noctarius/tengi?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge"]
Christoph Engelbert <https://github.com/noctarius[@noctarius2k]>
// Settings:
:compat-mode!:
:idseparator: -
// Aliases:
:project-name: tengi README
:project-handle: tengi-readme
:toc:

tengi is designed as a cross-language communication platform. Using several distinct transport layers, tengi always finds the most efficient way to communicate between the client and server. +
Available transports range from a plain _TCP_ transmission over _RDP_ (a reliable UDP implementation), standard _UDP_ or _HTTP Long-Polling_ as fallback.



== Features
=== Cutting-Edge Technology

tengi implements industry standards like socket layer communication using _TCP_ and _UDP_ but also offers support cutting-edge technologies like _SCTP_ and _HTTP2_ for future perspective. By transparently offering a variety of transportation layers using a common, flexible but simple and easy-to-use API, tengi is class-leading for the cross-language communication sector.

=== Simplicity driven APIs

The famous quote '`if you can't explain it to a six year old, you don't understand it yourself`', by Albert Einstein, is not only true to Physics but also to software APIs. Complex APIs prevent people from using your solution or have a very flat learning curve and getting started is a hard task. +
Good APIs are easy readable, self explanatory and fast to get started with.

tengi, for this reason, hides complexity behind a simple but powerful API. An echo-server example is less than 20 lines of code but complex tasks can be achieved using a rich set of system-hooks for advanced users.

=== Data Protocol and Reliability

tengi's default protocol is a highly bandwidth optimized serialization and transmission solution. Supporting compressed _int32_ and _int64_ data types (when 64 bit types are supported by client languages) as well as providing way to customly serialize objects guarantee minimal overhead.

Depending on the selected transport layer additional overhead is necessary (e.g. _HTTP_, _HTTP2_). Due to the fact tengi always finds the best communication path, ending up using expensive transports is very unlikely. Still tengi supports communication through corporate firewalls and unreliable networks (e.g. mobile providers).

=== Asynchronous and Reactivity

Reactive design principles and event driven systems are most common way to start nowadays scalable solutions. Therefore tengi offers full support of the reactive pattern. From bottom up the internal implementation is completely based on a reactive design and this is also passed to the user.

=== Performance and the Java Power

More and more developers start using Java, or better said the JVM (Java Virtual Machine), as the foundation for their backend technologies. Powerful JIT (Just-In-Time) compilation and optimization based on runtime behavior bundled with the automatic resource management are a perfect base for server systems. In addition tengi is optimized for high performance, low latency and minimal Garbage Collector pressure.

Using latest Java 8 features like Closures (Lambdas), interface evolution and optimized data structures provides a compact and future-oriented external API.

=== Cross-Language Clients

tengi is designed to provide a simple communication protocol. The protocol specification is fully documented and easy to implement on further languages.

Currently planned clients include, but are not limited to, C#, C++, HTML5 (using ASM.js) and ActionScript, next to an obvious Java client.

== Getting Started

=== Client Example

[source,java]
----
public void createEchoClient() {
  // Create configuration using the builder
  Configuration configuration = new ConfigurationBuilder()
    // Configure available transports
    .addTransport(ClientTransport.TCP_TRANSPORT, ClientTransport.HTTP_TRANSPORT)

    // Build final configuration
    .build();

  // Create client instance using configuration
  Client client = Client.create(configuration);

  // Connect to remote server
  client.connect("127.0.0.1", this::onConnect);
}

private void onConnect(Connection connection) {
  connection.addMessageListener(this::onMessage);

  Packet packet = new Packet("request");
  packet.setValue("name", "Steven");
  connection.writeObject(request);
}

private void onMessage(Connection connection, Message message) {
  Packet packet = message.getBody();
  String helloWorld = packet.getValue("response");
  System.out.println(helloWorld);
}
----

=== Server Example

[source,java]
----
public void createEchoServer() {
  // Create configuration using the builder
  Configuration configuration = new ConfigurationBuilder()
    // Configure available transports
    .addTransport(ServerTransport.TCP_TRANSPORT, ServerTransport.HTTP2_TRANSPORT,
                  ServerTransport.HTTP_TRANSPORT)

    // Build final configuration
    .build();

  // Create server instance using configuration
  Server server = Server.create(configuration);

  CompletableFuture<Channel> future = server.start(this::onConnect);
}

private void onConnect(Connection connection) {
  connection.addMessageListener(this::onMessage);
}

private void onMessage(Connection connection, Message message) {
  Packet packet = message.getBody();
  String name = packet.getValue("name");
  Packet response = new Packet("response");
  response.setValue("Hello World " + name);
  connection.writeObject(response);
}
----

== Maven Coordinates

== Javadoc

== API Walkthrough

=== Configuration

=== Core

==== Transports

===== TCP

===== UDP

===== RDP

===== WebSocket

===== HTTP2

===== HTTP Long-Polling

==== Connection

==== Listener

===== MessageListener

===== ConnectionListener

===== ConnectionConnectedListener

==== Logging

==== Serialization

===== Packet

===== Marshallable

===== Marshaller and MarshallerFilter

===== Message

===== Debugging

=== Server

==== Transports

==== Server

==== Broadcaster

=== Client

==== Transports

==== Client

== Protocol Specification

=== Data Types

=== Int32 Compression

=== Int64 Compression

=== String Serialization

=== TypeId

=== Protocol Header

=== Object Header
